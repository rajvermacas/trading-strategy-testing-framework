"""
Base strategy classes for trading strategy framework.

This module provides the foundation classes for implementing trading strategies
with a standardized interface for signal generation and indicator calculation.
"""

from abc import ABC, abstractmethod
from enum import Enum
from datetime import datetime
from typing import List, Dict, Any, Optional, Union
from dataclasses import dataclass


class SignalType(Enum):
    """Enumeration for different types of trading signals."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.
    
    Attributes:
        timestamp: When the signal was generated
        signal_type: Type of signal (BUY, SELL, HOLD)
        price: Price at which the signal was generated
        confidence: Confidence level of the signal (0.0 to 1.0)
        metadata: Additional information about the signal
    """
    timestamp: datetime
    signal_type: SignalType
    price: float
    confidence: float
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        """Initialize metadata if not provided."""
        if self.metadata is None:
            self.metadata = {}
    
    def __str__(self) -> str:
        """String representation of the signal."""
        return f"Signal({self.signal_type.value} at {self.price:.2f}, confidence={self.confidence:.2f})"


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This class defines the interface that all trading strategies must implement,
    including methods for calculating indicators and generating signals.
    """
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        """
        Initialize the strategy.
        
        Args:
            name: Human-readable name for the strategy
            config: Configuration parameters for the strategy
        """
        self.name = name
        self.config = config or {}
        
        # Validate configuration on initialization
        self.validate_config(self.config)
    
    @abstractmethod
    def calculate_indicators(self, market_data: List[Dict[str, Any]]) -> Dict[str, List[float]]:
        """
        Calculate technical indicators based on market data.
        
        Args:
            market_data: List of OHLCV data points
            
        Returns:
            Dictionary containing calculated indicators
        """
        pass
    
    @abstractmethod
    def generate_signal(self, market_data: List[Dict[str, Any]], 
                       indicators: Dict[str, List[float]]) -> Optional[Signal]:
        """
        Generate trading signal based on market data and indicators.
        
        Args:
            market_data: List of OHLCV data points
            indicators: Calculated technical indicators
            
        Returns:
            Signal object if a signal is generated, None otherwise
        """
        pass
    
    @abstractmethod
    def validate_config(self, config: Dict[str, Any]) -> None:
        """
        Validate strategy configuration parameters.
        
        Args:
            config: Configuration dictionary to validate
            
        Raises:
            ValueError: If configuration is invalid
        """
        pass
    
    @abstractmethod
    def get_required_params(self) -> List[str]:
        """
        Get list of required configuration parameters.
        
        Returns:
            List of required parameter names
        """
        pass
    
    def __str__(self) -> str:
        """String representation of the strategy."""
        return f"{self.__class__.__name__}(name='{self.name}')"
    
    def __repr__(self) -> str:
        """Detailed string representation of the strategy."""
        return f"{self.__class__.__name__}(name='{self.name}', config={self.config})"